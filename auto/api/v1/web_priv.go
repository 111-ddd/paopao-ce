// Code generated by go-mir. DO NOT EDIT.

package v1

import (
	"net/http"

	"github.com/alimy/mir/v3"
	"github.com/gin-gonic/gin"
	"github.com/rocboss/paopao-ce/internal/model/web"
)

type WebPriv interface {
	// Chain provide handlers chain for gin
	Chain() gin.HandlersChain

	DeleteCommentReply() mir.Error
	CreateCommentReply() mir.Error
	DeleteComment() mir.Error
	CreateComment() mir.Error
	VisiblePost() mir.Error
	StickTweet() mir.Error
	LockTweet() mir.Error
	CollectionTweet() mir.Error
	StarTweet() mir.Error
	DeleteTweet() mir.Error
	CreateTweet(*web.CreateTweetReq) (*web.CreateTweetResp, mir.Error)
	DownloadAttachment() mir.Error
	DownloadAttachmentPrecheck() mir.Error
	UploadAttachment() mir.Error

	mustEmbedUnimplementedWebPrivServant()
}

type WebPrivBinding interface {
	BindCreateTweet(*gin.Context) (*web.CreateTweetReq, mir.Error)

	mustEmbedUnimplementedWebPrivBinding()
}

type WebPrivRender interface {
	RenderDeleteCommentReply(*gin.Context, mir.Error)
	RenderCreateCommentReply(*gin.Context, mir.Error)
	RenderDeleteComment(*gin.Context, mir.Error)
	RenderCreateComment(*gin.Context, mir.Error)
	RenderVisiblePost(*gin.Context, mir.Error)
	RenderStickTweet(*gin.Context, mir.Error)
	RenderLockTweet(*gin.Context, mir.Error)
	RenderCollectionTweet(*gin.Context, mir.Error)
	RenderStarTweet(*gin.Context, mir.Error)
	RenderDeleteTweet(*gin.Context, mir.Error)
	RenderCreateTweet(*gin.Context, *web.CreateTweetResp, mir.Error)
	RenderDownloadAttachment(*gin.Context, mir.Error)
	RenderDownloadAttachmentPrecheck(*gin.Context, mir.Error)
	RenderUploadAttachment(*gin.Context, mir.Error)

	mustEmbedUnimplementedWebPrivRender()
}

// RegisterWebPrivServant register WebPriv servant to gin
func RegisterWebPrivServant(e *gin.Engine, s WebPriv, b WebPrivBinding, r WebPrivRender) {
	router := e.Group("v1")
	// use chain for router
	middlewares := s.Chain()
	router.Use(middlewares...)

	// register routes info to router
	router.Handle("DELETE", "/post/comment/reply", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		r.RenderDeleteCommentReply(c, s.DeleteCommentReply())
	})

	router.Handle("POST", "/post/comment/reply", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		r.RenderCreateCommentReply(c, s.CreateCommentReply())
	})

	router.Handle("DELETE", "/post/comment", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		r.RenderDeleteComment(c, s.DeleteComment())
	})

	router.Handle("POST", "/post/comment", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		r.RenderCreateComment(c, s.CreateComment())
	})

	router.Handle("POST", "/post/visibility", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		r.RenderVisiblePost(c, s.VisiblePost())
	})

	router.Handle("POST", "/post/stick", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		r.RenderStickTweet(c, s.StickTweet())
	})

	router.Handle("POST", "/post/lock", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		r.RenderLockTweet(c, s.LockTweet())
	})

	router.Handle("POST", "/post/collection", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		r.RenderCollectionTweet(c, s.CollectionTweet())
	})

	router.Handle("POST", "/post/start", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		r.RenderStarTweet(c, s.StarTweet())
	})

	router.Handle("DELETE", "/post", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		r.RenderDeleteTweet(c, s.DeleteTweet())
	})

	router.Handle("POST", "/post", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		req, err := b.BindCreateTweet(c)
		if err != nil {
			r.RenderCreateTweet(c, nil, err)
			return
		}
		resp, err := s.CreateTweet(req)
		r.RenderCreateTweet(c, resp, err)
	})

	router.Handle("GET", "/attachment", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		r.RenderDownloadAttachment(c, s.DownloadAttachment())
	})

	router.Handle("GET", "/attachment/precheck", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		r.RenderDownloadAttachmentPrecheck(c, s.DownloadAttachmentPrecheck())
	})

	router.Handle("POST", "/attachment", func(c *gin.Context) {
		select {
		case <-c.Request.Context().Done():
			return
		default:
		}

		r.RenderUploadAttachment(c, s.UploadAttachment())
	})

}

// UnimplementedWebPrivServant can be embedded to have forward compatible implementations.
type UnimplementedWebPrivServant struct {
}

func (UnimplementedWebPrivServant) Chain() gin.HandlersChain {
	return nil
}

func (UnimplementedWebPrivServant) DeleteCommentReply() mir.Error {
	return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) CreateCommentReply() mir.Error {
	return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) DeleteComment() mir.Error {
	return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) CreateComment() mir.Error {
	return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) VisiblePost() mir.Error {
	return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) StickTweet() mir.Error {
	return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) LockTweet() mir.Error {
	return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) CollectionTweet() mir.Error {
	return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) StarTweet() mir.Error {
	return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) DeleteTweet() mir.Error {
	return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) CreateTweet(req *web.CreateTweetReq) (*web.CreateTweetResp, mir.Error) {
	return nil, mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) DownloadAttachment() mir.Error {
	return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) DownloadAttachmentPrecheck() mir.Error {
	return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) UploadAttachment() mir.Error {
	return mir.Errorln(http.StatusNotImplemented, http.StatusText(http.StatusNotImplemented))
}

func (UnimplementedWebPrivServant) mustEmbedUnimplementedWebPrivServant() {}

// UnimplementedWebPrivRender can be embedded to have forward compatible implementations.
type UnimplementedWebPrivRender struct {
	RenderAny func(*gin.Context, any, mir.Error)
}

func (r *UnimplementedWebPrivRender) RenderDeleteCommentReply(c *gin.Context, err mir.Error) {
	r.RenderAny(c, nil, err)
}

func (r *UnimplementedWebPrivRender) RenderCreateCommentReply(c *gin.Context, err mir.Error) {
	r.RenderAny(c, nil, err)
}

func (r *UnimplementedWebPrivRender) RenderDeleteComment(c *gin.Context, err mir.Error) {
	r.RenderAny(c, nil, err)
}

func (r *UnimplementedWebPrivRender) RenderCreateComment(c *gin.Context, err mir.Error) {
	r.RenderAny(c, nil, err)
}

func (r *UnimplementedWebPrivRender) RenderVisiblePost(c *gin.Context, err mir.Error) {
	r.RenderAny(c, nil, err)
}

func (r *UnimplementedWebPrivRender) RenderStickTweet(c *gin.Context, err mir.Error) {
	r.RenderAny(c, nil, err)
}

func (r *UnimplementedWebPrivRender) RenderLockTweet(c *gin.Context, err mir.Error) {
	r.RenderAny(c, nil, err)
}

func (r *UnimplementedWebPrivRender) RenderCollectionTweet(c *gin.Context, err mir.Error) {
	r.RenderAny(c, nil, err)
}

func (r *UnimplementedWebPrivRender) RenderStarTweet(c *gin.Context, err mir.Error) {
	r.RenderAny(c, nil, err)
}

func (r *UnimplementedWebPrivRender) RenderDeleteTweet(c *gin.Context, err mir.Error) {
	r.RenderAny(c, nil, err)
}

func (r *UnimplementedWebPrivRender) RenderCreateTweet(c *gin.Context, data *web.CreateTweetResp, err mir.Error) {
	r.RenderAny(c, data, err)
}

func (r *UnimplementedWebPrivRender) RenderDownloadAttachment(c *gin.Context, err mir.Error) {
	r.RenderAny(c, nil, err)
}

func (r *UnimplementedWebPrivRender) RenderDownloadAttachmentPrecheck(c *gin.Context, err mir.Error) {
	r.RenderAny(c, nil, err)
}

func (r *UnimplementedWebPrivRender) RenderUploadAttachment(c *gin.Context, err mir.Error) {
	r.RenderAny(c, nil, err)
}

func (r *UnimplementedWebPrivRender) mustEmbedUnimplementedWebPrivRender() {}

// UnimplementedWebPrivBinding can be embedded to have forward compatible implementations.
type UnimplementedWebPrivBinding struct {
	BindAny func(*gin.Context, any) mir.Error
}

func (b *UnimplementedWebPrivBinding) BindCreateTweet(c *gin.Context) (*web.CreateTweetReq, mir.Error) {
	obj := new(web.CreateTweetReq)
	err := b.BindAny(c, obj)
	return obj, err
}

func (b *UnimplementedWebPrivBinding) mustEmbedUnimplementedWebPrivBinding() {}
